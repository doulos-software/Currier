Perl 6 Notes


# Single line comment

say #`(An embedded comment) "something"

=begin comment
	multi
	line
comment
=end comment


'plain string'

"string with'n $var stuff"


+		binary = addition
		unary = numeric coercion
-		binary = subtraction
		unary = negated numeric coercion
*		multiplication
**		power
/		division
div 	integer division
%		modulo
%%		divisibility
gcd		greatest common denominator
lcm		least common multiple
==		numeric equal
!=		numeric unequal
<		less than
>		greater than
<=		less than or equal
>=		greater than or equal
eq 		string equal
ne 		string not equal
=		assignment
~		string concatenation
x		string replication
~~		smart match (returns T/F or match?)
++		increment
--		decrement
?		coerce to a boolean
!		coerce (negated) to a boolean
..		range constructor
^..		internal range constructors
..^
^..^
^		~ this one implies a zero range floor
...		lazy list constructor
|		flattener
.=		enforce a function (as a mutator)

R*		precede any operator with 'R' to reverse it

Reduction Operation
	[+] 1,2,3,4,5	is the same as 	1+2+3+4+5


$var	scalar
@var	array
%var	hash


Scalars
	string
	integer
	rational

Arrays
	my @array 		# a basic array
	my @array[3]	# fixed size array
	my @array[3;2]	# multi-dimensional array

Hashes
	my %capitals = ('','','','')
	%capitals<Key>


Typing
	Perl6 is _gradually typed_

	Mu 		Perl6 root type
	Any
	Cool 	string or number?
	Str
	Int
	Rat 	rational number
	Bool


Perl6 is lexically scoped

Functions are immutable
	i.e. same arguments = same results ALWAYS

Mutators modify the calling object


Control
	if ... {	... } elsif { ... } else { ... }

	say 'Welcome' if ...;

	unless ... {	... }

	with ... {	... } orwith { ... }

	without ... {	...	}

	for @array -> $item { ... }

	given $var {
		when ... { ... }
		when Int { ... }
		default { ... }
	}

	loop (my $i=0; $i < 9; $I++) { ... }


Terminal
	$prompt = get;

	my $input = prompt "Prompt>> ";

	run 'echo', "hello $name";

	shell 'dir';


Files
	slurp ~ read data from a file
		my $data = slurp "datafile.txt"

	spurt ~ write data to a file

	dir ~ directory contents
	mkdir
	rmdir

	"file.txt".IO.e ~ exists?
	"file.txt".IO.f ~ isFile?
	"file.txt".IO.d ~ isDirectory?


Subroutines
	Without signature:
		sub asdf {
			...
			# final command is returned
		}

	With signature:
		sub hello (Str $name) {
			say "Hello " ~ $name ~ "!!!!"
		}

	Multiple dispatch:
		multi A ($X) { ... }

		multi A ($X, $Y) { ...; A($X); }

	Options:
		sub say-hello($name) {
			with $name { say "Hello " ~ $name }
			else { say "Howdy" }
		}

	Defaults:
		sub say-hello($name="Matt") {
			say "Hello " ~ $name;
		}

	Implicit Return:
		# returns the last thing
		sub squared ($x) { $x ** 2 }

	Explicit Return:
		sub squared ($x) { return $x ** 2 }

	Return Type Trait:
		sub squared ($x) returns Int { return $x ** 2 }

	Return Type Constraint:
		sub squared ($x --> Int) { return $x ** 2 }

		sub squared ($x --> Int:D) { return $x ** 2 }

	Functions are first-class things
		my @array = <1 2 3 4 5>;
		sub squared ($x) { $x ** 2 }
		say map(&squared, @array)

	Anonymity
		$x -> { ... }

	Chaining
		@array.unique.sort.reverse

		@array
		==> unique()
		==> sort()
		==> reverse()
		==> my @final-array
		;

		my @final-array
		<== reverse()
		<== sort()
		<== unique()
		<== @array
		;

	Hyper Operator
		@array>>.is-prime;	# returns a list of boolean results

	Junctions
		my $var = 2;
		if $var == 1|2|3 { say "The variable is 1 or 2 or 3" }

	Lazy Lists
		(1 ... 10)

		(1 ... Inf)

		(0,2 ... 10)

		(0, { $_ + 3 } ... 12);	# with a generator, produces (0 3 6 9 12)

		(0, { $_ + 3 } ...^ * > 10);	# stops on any value over 10

Object Orientation
	class based

	twigils - between a sigil and an attribute
		! declares an attribute to be private
		. generates an accessor

	class Human {
		my $.counter = 0;	# this is a class attribute, not an object attribute

		has $!name;	# these are object attributes
		has $!age;	# the bang means 'private'
		has $!sex is rw;	# thisn is read/write

		method new ($name, $age, $sex) {
			Human.counter++;

			self.bless(:$name, :$age, :$sex);
		}

		method !private_method { ... }
	}

	self.age 	# calls the .age accessor method
	$!age 	# is a direct call to the variable


